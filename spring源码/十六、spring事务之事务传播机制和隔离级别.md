# Spring事务传播行为
运用Spring事务，必须要深入理解它的传播机制，否则会遇到各种意想不到的坑,Spring定义了七种传播行为。
```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
}
```
含义如下：
传播行为|官方含义|简单理解|
---|-----------------------|-----------------------|
PROPAGATION_REQUIRED|表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务|有事务就用已有的，没有就重新开启一个
PROPAGATION_SUPPORTS|表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行|有事务就用已有的，没有也不会重新开启
PROPAGATION_MANDATORY|表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常|必须要有事务，没事务抛异常
PROPAGATION_REQUIRES_NEW|表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起|开启新事务，若当前已有事务，挂起当前事务
PROPAGATION_NOT_SUPPORTED|表示该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起|不需要事务，若当前已有事务，挂起当前事务
PROPAGATION_NEVER|表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常|不需要事务，若当前已有事务，抛出异常
PROPAGATION_NESTED|表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像PROPAGATION_REQUIRES一样|嵌套事务，如果外部事务回滚，则嵌套事务也会回滚！！！外部事务提交的时候，嵌套它才会被提交。嵌套事务回滚不会影响外部事务。
Spring的@Transactional默认是PROPAGATION_REQUIRED。
# 隔离级别
> 隔离级别转载自[http://www.javaseo.cn/article/88/](http://www.javaseo.cn/article/88/)

Spring的事务隔离级别最终还是交给数据库处理，Spring并没有做特殊处理。
1. Read uncommitted 读未提交
公司发工资了，把50000元打到我的账号上，但是该事务并未提交，而我正好去查看账户，发现工资已经到账，是50000元整，非常高兴。可是不幸的是，领导发现发给的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后我实际的工资只有2000元，空欢喜一场。
脏读是两个并发的事务，“事务A：领导发工资”、“事务B：我查询工资账户”，事务B读取了事务A尚未提交的数据。
当隔离级别设置为Read uncommitted时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。
2. Read committed 读提交
我拿着工资卡去消费，系统读取到卡里确实有2000元，而此时老婆也正好在网上转账，把工资卡的2000元转到她账户，并在我之前提交了事务，当我扣款时，系统检查到工资卡已经没有钱，扣款失败，十分纳闷，明明卡里有钱，为何......
不可重复读是两个并发的事务，“事务A：消费”、“事务B：老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。
3. Repeatable read 重复读
当隔离级别设置为Repeatable read时，可以避免不可重复读。当我拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），我老婆就不可能对该记录进行修改，也就是不能在此时转账。
虽然Repeatable read避免了不可重复读，但还有可能出现幻读。例如：老婆工作在银行部门，她时常通过银行内部系统查看我的信用卡消费记录。有一天，她正查询到我当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而我此时正好在外面吃完大餐后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction ... ），并提交了事务，随后老婆将我的当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，老婆很诧异，以为出现了幻觉，幻读就这样产生了。
4. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。